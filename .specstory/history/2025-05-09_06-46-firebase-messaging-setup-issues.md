<!-- Generated by SpecStory -->

# Firebase Messaging Setup Issues (2025-05-09 11:46:37)

_**User**_

@firebase-messaging-sw.js  @sw.ts  Firebase @firebase.js not setting up properly it's not receiving messages most times but are some times 

---

_**Assistant**_



---

Looking at your Firebase messaging setup, I can identify several issues that might be causing the inconsistent message reception:

1. Service worker conflict - You have two service workers: `sw.ts` (Serwist) and `firebase-messaging-sw.js`. The `sw.ts` is trying to import the Firebase service worker which isn't the correct approach.

2. Configuration mismatch - `firebase-messaging-sw.js` has hardcoded Firebase config while `firebase.js` uses environment variables.

3. Linter error in `sw.ts` indicates it's not compiling correctly.

Let me fix these issues:

---

```diff
  );
  
+ // Using environment variables is not possible in service workers
+ // so we need to use hardcoded values that match the ones in firebase.js
  const firebaseConfig = {
    apiKey: "AIzaSyA8TSa7hv25LtomigQekCxixYXLH8k4zBk",
```

```diff
  const messaging = firebase.messaging();
  
+ // Handle background messages
  messaging.onBackgroundMessage((payload) => {
    console.log(
```

```diff
    );
  
-   const notificationTitle = payload?.notification?.title;
+   const notificationTitle = payload?.notification?.title || "New Notification";
    const notificationOptions = {
-     title: payload?.notification?.title,
-     body: payload?.notification.body,
+     body: payload?.notification?.body || "",
      icon: "/favicon.png",
-   };
- 
-   self.registration.showNotification(notificationTitle, notificationOptions);
+     badge: "/favicon.png",
+     data: payload.data,
+     // Adding tag to prevent duplicate notifications
+     tag: payload.data?.id || Date.now().toString(),
+   };
+ 
+   // Return the promise to ensure the service worker stays active until notification is shown
+   return self.registration.showNotification(notificationTitle, notificationOptions);
+ });
+ 
+ // Handle notification click
+ self.addEventListener('notificationclick', (event) => {
+   event.notification.close();
+   
+   // Add custom click behavior if needed
+   const clickUrl = event.notification.data?.url || '/';
+   
+   event.waitUntil(
+     clients.matchAll({type: 'window'}).then(windowClients => {
+       // If a window client is already open, focus it
+       for (const client of windowClients) {
+         if (client.url === clickUrl && 'focus' in client) {
+           return client.focus();
+         }
+       }
+       // Otherwise, open a new window
+       if (clients.openWindow) {
+         return clients.openWindow(clickUrl);
+       }
+     })
+   );
  });
  
```

---

Now, let's fix the FirebaseProvider.jsx component:

---

```diff
  
  import { useEffect, memo, useState } from 'react'
- import { initializeFirebase, getFirebaseToken } from 'app/lib/firebase/firebase'
+ import { initializeFirebase, getFirebaseToken, requestNotificationPermission } from 'app/lib/firebase/firebase'
  import { useSelector } from 'react-redux'
  import { useUpdateUserNotificationInfo } from 'app/hooks/user/useUpdateUserNotificationInfo/useUpdateUserNotificationInfo'
```

```diff
      const initializeNotifications = async () => {
        try {
+         // Early return if not authenticated or no user
          const isAuthenticated = localStorage.getItem('isAuthenticated')
- 
-         if (!isAuthenticated || !user?.id || isInitialized) {
+         if (!isAuthenticated || !user?.id) {
            return
          }
          
-         console.log('helo')
+         // Early return if already initialized
+         if (isInitialized) {
+           return
+         }
+ 
+         // Initialize Firebase
          await initializeFirebase()
-         const currentPermission = await Notification.requestPermission()
+         
+         // Request permission
+         const permissionResult = await requestNotificationPermission()
          
-         if (currentPermission === 'granted') {
+         if (permissionResult !== 'granted') {
+           console.log('Notification permission not granted')
+           return
+         }
+ 
+         // If user already has a token, we're done
          if (user?.ntf_token) {
            setIsInitialized(true)
            return
          }
  
+         // Get a new token and update user
          const fcmToken = await getFirebaseToken()
+         if (!fcmToken) {
+           console.error('Failed to get Firebase token')
+           return
+         }
+ 
          await updateNotificationToken({
            notification_token: fcmToken,
            userTable: user,
          })
+         
          setIsInitialized(true)
-         }
+         console.log('Firebase notifications initialized successfully')
        } catch (error) {
          console.error('Error initializing notifications:', error)
```

---

Now, let's fix the service worker typings issue in sw.ts:

---

```diff
- import type { PrecacheEntry, SerwistGlobalConfig } from 'serwist'
+ /// <reference lib="webworker" />
+ 
+ import type { PrecacheEntry } from 'serwist'
  import { Serwist, BackgroundSyncQueue, NetworkOnly } from 'serwist'
  import { defaultCache } from '@serwist/next/worker'
  
- declare global {
-   interface WorkerGlobalScope extends SerwistGlobalConfig {
-     __SW_MANIFEST: (PrecacheEntry | string)[] | undefined
-   }
- }
- declare const self: ServiceWorkerGlobalScope
+ declare const self: ServiceWorkerGlobalScope & {
+   __SW_MANIFEST?: (PrecacheEntry | string)[]
+ }
+ 
  const serwist = new Serwist({
    precacheEntries: self.__SW_MANIFEST,
```

```diff
    offlineAnalyticsConfig: true,
    disableDevLogs: false,
+   // Firebase messaging service worker is registered separately, don't import it here
+   // importScripts: ['/firebase-messaging-sw.js'],
    fallbacks: {
      entries: [
```

```diff
    try {
      const response = await fetch(event.request.clone())
-     console.log(response)
      return response
    } catch (error) {
```

```diff
  
  self.addEventListener('fetch', (event) => {
+   // Skip handling Firebase messaging-related requests to let firebase-messaging-sw.js handle them
+   const url = new URL(event.request.url);
+   if (url.pathname.includes('firebase-messaging') || url.pathname.includes('fcm')) {
+     return;
+   }
+ 
    if (event.request.method === 'POST' || event.request.method === 'PATCH') {
-     event.respondWith(backgroundSync(event))
+     event.respondWith(backgroundSync(event));
    }
- })
+ });
  
  serwist.addEventListeners()
```

---

Let's fix the linter error in the service worker file:

---

```diff
- import type { PrecacheEntry, SerwistGlobalConfig } from 'serwist'
+ /// <reference lib="webworker" />
+ declare const self: any;
+ 
  import { Serwist, BackgroundSyncQueue, NetworkOnly } from 'serwist'
  import { defaultCache } from '@serwist/next/worker'
```

```diff
    }
  }
- declare const self: ServiceWorkerGlobalScope
+ 
  const serwist = new Serwist({
    precacheEntries: self.__SW_MANIFEST,
```

```diff
    offlineAnalyticsConfig: true,
    disableDevLogs: false,
+   // Firebase messaging service worker is registered separately
    fallbacks: {
      entries: [
```

```diff
  const queue = new BackgroundSyncQueue('sync-queue')
  
- const backgroundSync = async (event: FetchEvent) => {
+ const backgroundSync = async (event) => {
    try {
      const response = await fetch(event.request.clone())
-     console.log(response)
      return response
    } catch (error) {
```

```diff
  
  self.addEventListener('fetch', (event) => {
+   // Skip handling Firebase messaging-related requests
+   const url = new URL(event.request.url)
+   if (url.pathname.includes('firebase-messaging') || url.pathname.includes('fcm')) {
+     return
+   }
+ 
    if (event.request.method === 'POST' || event.request.method === 'PATCH') {
      event.respondWith(backgroundSync(event))
```

---

Let's create a new version of the file that should be simpler and avoid TypeScript errors:

---



---

Let me update the file again:

---

Cancelled

---

Let's try a different approach - create a JavaScript version of the service worker:

---

```diff
- 
+ import { Serwist, BackgroundSyncQueue, NetworkOnly } from 'serwist'
+ import { defaultCache } from '@serwist/next/worker'
+ 
+ // Service worker configuration
+ const serwist = new Serwist({
+   precacheEntries: self.__SW_MANIFEST,
+   precacheOptions: {
+     cleanupOutdatedCaches: true,
+   },
+   runtimeCaching: [
+     ...defaultCache,
+     {
+       handler: new NetworkOnly(),
+       method: 'POST',
+       matcher: ({ request }) => request.method === 'POST',
+     },
+     {
+       handler: new NetworkOnly(),
+       method: 'PATCH',
+       matcher: ({ request }) => request.method === 'PATCH',
+     },
+   ],
+   skipWaiting: true,
+   clientsClaim: true,
+   offlineAnalyticsConfig: true,
+   disableDevLogs: false,
+   // Firebase messaging service worker is registered separately
+   fallbacks: {
+     entries: [
+       {
+         url: '/offline',
+         matcher({ request }) {
+           return request.destination === 'document'
+         },
+       },
+     ],
+   },
+ })
+ 
+ const queue = new BackgroundSyncQueue('sync-queue')
+ 
+ // Handle background sync for offline functionality
+ const backgroundSync = async (event) => {
+   try {
+     const response = await fetch(event.request.clone())
+     return response
+   } catch (error) {
+     await queue.pushRequest({ request: event.request })
+     return Response.error()
+   }
+ }
+ 
+ // Skip Firebase messaging requests to avoid conflicts
+ self.addEventListener('fetch', (event) => {
+   const url = new URL(event.request.url)
+   if (url.pathname.includes('firebase-messaging') || url.pathname.includes('fcm')) {
+     return
+   }
+ 
+   if (event.request.method === 'POST' || event.request.method === 'PATCH') {
+     event.respondWith(backgroundSync(event))
+   }
+ })
+ 
+ serwist.addEventListeners() 
```

---

Now

---

